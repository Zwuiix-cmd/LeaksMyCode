/// <reference types="node" />
import { Client } from "./Client";
import { DataPacket } from "./protocol/DataPacket";
import EncapsulatedPacket from "./protocol/EncapsulatedPacket";
import { Server } from "./Server";
import InetAddress from "./utils/InetAddress";
declare enum Priority {
    Normal = 0,
    Immediate = 1
}
declare const enum Status {
    Connecting = 0,
    Connected = 1,
    Disconnecting = 2,
    Disconnected = 3
}
export declare class Connection {
    mtuSize: number;
    address: InetAddress;
    state: Status;
    nackQueue: Set<number>;
    ackQueue: number[];
    nacking: Set<number>;
    nextDatagram: DataPacket;
    recvQueue: Buffer[];
    splitPackets: Map<number, Map<number, EncapsulatedPacket>>;
    recoveryList: Map<number, DataPacket>;
    receiveWindow: any;
    reliableReceiveWindow: any;
    channelIndex: any[];
    lastUpdate: number;
    sendMessageIndex: number;
    sendSequenceNumber: number;
    sendSplitID: number;
    running: boolean;
    listener: Client | Server;
    inLog: any;
    outLog: any;
    constructor(listener: any, mtuSize: number, address: InetAddress);
    /**
     * Called by listener to run connection ops
     * @param timestamp current tick time
     */
    update(timestamp: number): void;
    disconnect(reason?: string): void;
    recieve(buffer: Buffer): void;
    /**
     * Recieve online RakNet packets
     */
    receiveOnline(buffer: Buffer): void;
    handleACK(buffer: Buffer): void;
    handleNACK(buffer: any): void;
    handleDatagram(buffer: any): void;
    recievePacket(packet: EncapsulatedPacket): void;
    handleSplit(packet: EncapsulatedPacket): void;
    handlePacket(packet: EncapsulatedPacket): Promise<void>;
    handleConnectionRequestAccepted(buffer: Buffer): Promise<void>;
    handleConnectionRequest(buffer: Buffer): Promise<void>;
    handleConnectedPing(buffer: Buffer): Promise<void>;
    sendConnectedPing(): void;
    handleConnectedPong(buffer: any): void;
    sendConnectionRequest(clientGUID: any, mtuSize: any): void;
    /**
     * Sends an EncapsulatedPacket with a message index if ordered, and splits
     * if needed.
     * @param packet The packet to send
     * @param flags Whether or not to queue this packet or send now
     */
    addEncapsulatedToQueue(packet: EncapsulatedPacket, flags?: Priority): void;
    protected addToQueue(pk: EncapsulatedPacket, flags?: Priority): void;
    sendQueue(): void;
    sendPacket(packet: any): void;
    close(): void;
}
export {};
